module Main exposing (main)

import Node
import ChildProcess
import Init
import Stream exposing (Stream)
import Task
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = \_model -> Sub.none
        }


type alias Model = 
    { args : Array String
    , stdout : Stream
    , stderr : Stream
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , remotePath : String
    , localPath : Path
    }


compilerVersion : String
compilerVersion =
    "0.3.0"


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
    Init.await ChildProcess.initialize <| \cpPermission ->
    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
    Init.awaitTask Path.homeDirectory <| \homeDir ->
            let
                userArgs =
                    Array.dropFirst 2 env.args

                maybePaths =
                    case { platform = env.platform, arch = env.cpuArchitecture } of
                        { platform = Node.Win32, arch = Node.X64 } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = makeRemotePath "gren.exe"
                                , localPath = makeLocalPath env.platform homeDir envVars
                                }

                        { platform = Node.Darwin } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = makeRemotePath "gren_mac"
                                , localPath = makeLocalPath env.platform homeDir envVars
                                }

                        { platform = Node.Linux, arch = Node.X64 } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = makeRemotePath "gren_linux"
                                , localPath = makeLocalPath env.platform homeDir envVars
                                }

                        _ ->
                            Nothing

                model =
                    case maybePaths of
                        Just paths ->
                            { args = userArgs
                            , stdout = env.stdout
                            , stderr = env.stderr
                            , fsPermission = fsPermission
                            , cpPermission = cpPermission
                            , remotePath = paths.remotePath
                            , localPath = paths.localPath
                            }
                        
                        Nothing ->
                            -- dummy model
                            { args = []
                            , stdout = env.stdout
                            , stderr = env.stderr
                            , fsPermission = fsPermission
                            , cpPermission = cpPermission
                            , remotePath = ""
                            , localPath = Path.empty
                            }
            in
            Node.startProgram
                { model = model
                , command =
                    case maybePaths of
                        Just _ ->
                            FileSystem.checkAccess fsPermission [] model.localPath
                                |> Task.attempt ExistanceChecked

                        Nothing ->
                            Stream.sendLine env.stderr "We currently don't support this platform/arch."
                                |> Task.execute
                }


makeRemotePath : String -> String
makeRemotePath filename =
    String.join "/"
        [ "https://github.com/gren-lang/compiler/releases/download"
        , compilerVersion
        , filename
        ]


makeLocalPath : Node.Platform -> Path -> Dict String String -> Path
makeLocalPath platform homeDir envVars =
    let
        startPath =
            case platform of
                Node.Win32 ->
                    envVars
                        |> Dict.get "LOCALAPPDATA"
                        |> Maybe.map Path.fromWin32String
                        |> Maybe.withDefault (
                            "AppData/Local"
                                |> Path.fromPosixString
                                |> Path.prepend homeDir
                            )

                Node.Darwin ->
                    "Library/Caches"
                        |> Path.fromPosixString
                        |> Path.prepend homeDir

                _ ->
                    envVars
                        |> Dict.get "XDG_CACHE_HOME"
                        |> Maybe.map Path.fromPosixString
                        |> Maybe.withDefault (Path.append (Path.fromPosixString ".cache") homeDir)

        filename =
            case platform of
                Node.Win32 ->
                    "gren.exe"

                _ ->
                    "gren"
        
        endPath =
            [ "gren"
            , compilerVersion
            , "bin"
            , filename
            ]
                |> String.join "/"
                |> Path.fromPosixString
    in
    Path.prepend startPath endPath


type Msg
    = ExistanceChecked (Result FileSystem.Error Path)
    | CompilerExecuted (Result ChildProcess.FailedRun ChildProcess.SuccessfulRun)



update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    case msg of
        ExistanceChecked (Err _) ->
            { model = model
            , command =
                Stream.sendLine model.stdout ("Compiler not found at " ++ Path.toPosixString model.localPath ++ ". Downloading...")
                    |> Task.execute
            }

        ExistanceChecked (Ok _) ->
            { model = model
            , command =
                ChildProcess.runWithDefaultOptions model.cpPermission (Path.toPosixString model.localPath) model.args
                    |> Task.attempt CompilerExecuted
            }
            
        CompilerExecuted (Err output) ->
            { model = model
            , command =
                Stream.send model.stdout output.stdout
                    |> Task.andThen (\_ -> Stream.send model.stderr output.stderr)
                    |> Task.andThen (\_ -> Node.exitWithCode output.exitCode)
                    |> Task.execute
            }

        CompilerExecuted (Ok output) ->
            { model = model
            , command =
                Stream.send model.stdout output.stdout
                    |> Task.andThen (\_ -> Stream.send model.stderr output.stderr)
                    |> Task.execute
            }

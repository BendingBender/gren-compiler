module Main exposing (main)

import Node
import ChildProcess
import Init
import Stream exposing (Stream)
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import Bytes exposing (Bytes)


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = \_model -> Sub.none
        }


type alias Model = 
    { args : Array String
    , stdout : Stream
    , stderr : Stream
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , httpPermission : HttpClient.Permission
    , remotePath : String
    , localPath : Path
    }


compilerVersion : String
compilerVersion =
    "0.3.0"


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
    Init.await ChildProcess.initialize <| \cpPermission ->
    Init.await HttpClient.initialize <| \httpPermission ->
    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
    Init.awaitTask (FileSystem.homeDirectory fsPermission) <| \homeDir ->
            let
                userArgs =
                    Array.dropFirst 2 env.args

                maybePaths =
                    case { platform = env.platform, arch = env.cpuArchitecture } of
                        { platform = Node.Win32, arch = Node.X64 } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = makeRemotePath "gren.exe"
                                , localPath = makeLocalPath env.platform homeDir envVars
                                }

                        { platform = Node.Darwin } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = makeRemotePath "gren_mac"
                                , localPath = makeLocalPath env.platform homeDir envVars
                                }

                        { platform = Node.Linux, arch = Node.X64 } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = makeRemotePath "gren_linux"
                                , localPath = makeLocalPath env.platform homeDir envVars
                                }

                        _ ->
                            Nothing

                model =
                    case maybePaths of
                        Just paths ->
                            { args = userArgs
                            , stdout = env.stdout
                            , stderr = env.stderr
                            , fsPermission = fsPermission
                            , cpPermission = cpPermission
                            , httpPermission = httpPermission
                            , remotePath = paths.remotePath
                            , localPath = paths.localPath
                            }
                        
                        Nothing ->
                            -- dummy model
                            { args = []
                            , stdout = env.stdout
                            , stderr = env.stderr
                            , fsPermission = fsPermission
                            , cpPermission = cpPermission
                            , httpPermission = httpPermission
                            , remotePath = ""
                            , localPath = Path.empty
                            }
            in
            Node.startProgram
                { model = model
                , command =
                    case maybePaths of
                        Just _ ->
                            FileSystem.checkAccess fsPermission [] model.localPath
                                |> Task.attempt ExistanceChecked

                        Nothing ->
                            Stream.sendLine env.stderr "We currently don't support this platform/arch."
                                |> Task.execute
                }


makeRemotePath : String -> String
makeRemotePath filename =
    String.join "/"
        [ "https://github.com/gren-lang/compiler/releases/download"
        , compilerVersion
        , filename
        ]


makeLocalPath : Node.Platform -> Path -> Dict String String -> Path
makeLocalPath platform homeDir envVars =
    let
        startPath =
            case platform of
                Node.Win32 ->
                    envVars
                        |> Dict.get "LOCALAPPDATA"
                        |> Maybe.map Path.fromWin32String
                        |> Maybe.withDefault (
                            "AppData/Local"
                                |> Path.fromPosixString
                                |> Path.prepend homeDir
                            )

                Node.Darwin ->
                    "Library/Caches"
                        |> Path.fromPosixString
                        |> Path.prepend homeDir

                _ ->
                    envVars
                        |> Dict.get "XDG_CACHE_HOME"
                        |> Maybe.map Path.fromPosixString
                        |> Maybe.withDefault (Path.append (Path.fromPosixString ".cache") homeDir)

        filename =
            case platform of
                Node.Win32 ->
                    "gren.exe"

                _ ->
                    "gren"
        
        endPath =
            [ "gren"
            , compilerVersion
            , "bin"
            , filename
            ]
                |> String.join "/"
                |> Path.fromPosixString
    in
    Path.prepend startPath endPath


type Msg
    = ExistanceChecked (Result FileSystem.Error Path)
    | CompilerDownloaded (Result (HttpClient.Error Bytes) (HttpClient.Response Bytes))
    | CompilerExecuted (Result ChildProcess.FailedRun ChildProcess.SuccessfulRun)


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    case msg of
        ExistanceChecked (Err _) ->
            { model = model
            , command =
                Stream.sendLine model.stdout ("Compiler not found at " ++ Path.toPosixString model.localPath ++ ". Downloading...")
                    |> Task.andThen (\{} -> downloadBinary model.httpPermission model.remotePath)
                    |> Task.attempt CompilerDownloaded
            }

        ExistanceChecked (Ok _) ->
            { model = model
            , command =
                ChildProcess.runWithDefaultOptions model.cpPermission (Path.toPosixString model.localPath) model.args
                    |> Task.attempt CompilerExecuted
            }

        CompilerDownloaded (Err err) ->
            { model = model
            , command =
                Stream.sendLine model.stderr (HttpClient.errorToString err)
                    |> Task.execute
            }
        
        CompilerDownloaded (Ok res) ->
            { model = model
            , command =
                Stream.sendLine model.stdout (Debug.toString res)
                    |> Task.execute
            }
            
        CompilerExecuted (Err output) ->
            { model = model
            , command =
                Stream.send model.stdout output.stdout
                    |> Task.andThen (\_ -> Stream.send model.stderr output.stderr)
                    |> Task.andThen (\_ -> Node.exitWithCode output.exitCode)
                    |> Task.execute
            }

        CompilerExecuted (Ok output) ->
            { model = model
            , command =
                Stream.send model.stdout output.stdout
                    |> Task.andThen (\_ -> Stream.send model.stderr output.stderr)
                    |> Task.execute
            }


downloadBinary : HttpClient.Permission -> String -> Task (HttpClient.Error Bytes) (HttpClient.Response Bytes)
downloadBinary permission url =
    HttpClient.get url
        |> HttpClient.expectBytes
        |> HttpClient.send permission
